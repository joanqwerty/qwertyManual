{"config":{"index_content":true,"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gu\u00eda de Aprendizaje QwertyManual \u00a1Bienvenido a mi Gu\u00eda de Aprendizaje! Esta documentaci\u00f3n representa una cuidadosa recopilaci\u00f3n de conocimientos, experiencias y recursos que he adquirido a lo largo de mi trayectoria educativa y profesional en el mundo de la tecnolog\u00eda. \u00bfQu\u00e9 encontrar\u00e1s aqu\u00ed? En esta gu\u00eda descubrir\u00e1s una amplia variedad de contenido estructurado y organizado, que incluye: Recursos educativos sobre diferentes tecnolog\u00edas Desarrollo de software y mejores pr\u00e1cticas Herramientas y frameworks modernos Tutoriales paso a paso para diferentes niveles Tips y consejos basados en experiencia real Proyectos pr\u00e1cticos y ejemplos de c\u00f3digo Para qui\u00e9n es esta gu\u00eda Esta documentaci\u00f3n est\u00e1 pensada tanto para principiantes que est\u00e1n dando sus primeros pasos en tecnolog\u00eda, como para desarrolladores con experiencia que buscan expandir sus conocimientos o encontrar referencias r\u00e1pidas. Navegaci\u00f3n El contenido est\u00e1 organizado de manera l\u00f3gica y progresiva. Te recomiendo comenzar por los fundamentos si eres principiante, o navegar directamente a los temas espec\u00edficos de tu inter\u00e9s si ya tienes experiencia. Contribuir al Proyecto Este proyecto es de c\u00f3digo abierto y las contribuciones son bienvenidas. Si deseas aportar: Visita el repositorio en GitHub Revisa las gu\u00edas de contribuci\u00f3n Crea un fork del proyecto Env\u00eda tus pull requests Toda contribuci\u00f3n, desde correcciones menores hasta nuevos contenidos, es valorada y apreciada. \u00a1Espero que esta gu\u00eda sea de gran utilidad en tu camino de aprendizaje! No dudes en explorar, practicar y aplicar estos conocimientos en tus propios proyectos.","title":"Introducci\u00f3n"},{"location":"#guia-de-aprendizaje-qwertymanual","text":"","title":"Gu\u00eda de Aprendizaje QwertyManual"},{"location":"#bienvenido-a-mi-guia-de-aprendizaje","text":"Esta documentaci\u00f3n representa una cuidadosa recopilaci\u00f3n de conocimientos, experiencias y recursos que he adquirido a lo largo de mi trayectoria educativa y profesional en el mundo de la tecnolog\u00eda.","title":"\u00a1Bienvenido a mi Gu\u00eda de Aprendizaje!"},{"location":"#que-encontraras-aqui","text":"En esta gu\u00eda descubrir\u00e1s una amplia variedad de contenido estructurado y organizado, que incluye: Recursos educativos sobre diferentes tecnolog\u00edas Desarrollo de software y mejores pr\u00e1cticas Herramientas y frameworks modernos Tutoriales paso a paso para diferentes niveles Tips y consejos basados en experiencia real Proyectos pr\u00e1cticos y ejemplos de c\u00f3digo","title":"\u00bfQu\u00e9 encontrar\u00e1s aqu\u00ed?"},{"location":"#para-quien-es-esta-guia","text":"Esta documentaci\u00f3n est\u00e1 pensada tanto para principiantes que est\u00e1n dando sus primeros pasos en tecnolog\u00eda, como para desarrolladores con experiencia que buscan expandir sus conocimientos o encontrar referencias r\u00e1pidas.","title":"Para qui\u00e9n es esta gu\u00eda"},{"location":"#navegacion","text":"El contenido est\u00e1 organizado de manera l\u00f3gica y progresiva. Te recomiendo comenzar por los fundamentos si eres principiante, o navegar directamente a los temas espec\u00edficos de tu inter\u00e9s si ya tienes experiencia.","title":"Navegaci\u00f3n"},{"location":"#contribuir-al-proyecto","text":"Este proyecto es de c\u00f3digo abierto y las contribuciones son bienvenidas. Si deseas aportar: Visita el repositorio en GitHub Revisa las gu\u00edas de contribuci\u00f3n Crea un fork del proyecto Env\u00eda tus pull requests Toda contribuci\u00f3n, desde correcciones menores hasta nuevos contenidos, es valorada y apreciada. \u00a1Espero que esta gu\u00eda sea de gran utilidad en tu camino de aprendizaje! No dudes en explorar, practicar y aplicar estos conocimientos en tus propios proyectos.","title":"Contribuir al Proyecto"},{"location":"Programacion/","text":"Guia de programaci\u00f3n","title":"Guia de programaci\u00f3n"},{"location":"Programacion/#guia-de-programacion","text":"","title":"Guia de programaci\u00f3n"},{"location":"linux-development/","text":"Gu\u00eda completa para crear tu propia distribuci\u00f3n Linux Embebido Introducci\u00f3n Crear tu propia distribuci\u00f3n Linux embebida es una de las formas m\u00e1s efectivas de comprender c\u00f3mo funciona realmente el sistema operativo Linux. Esta gu\u00eda est\u00e1 dise\u00f1ada para llevarte paso a paso desde los fundamentos del sistema hasta la creaci\u00f3n de una imagen funcional personalizada, adaptada a hardware espec\u00edfico o a un prop\u00f3sito determinado (como kioskos, c\u00e1maras inteligentes o controladores industriales). A lo largo de esta gu\u00eda aprender\u00e1s c\u00f3mo est\u00e1 compuesto Linux, c\u00f3mo se construye desde cero y c\u00f3mo integrarlo en un entorno embebido optimizado y confiable. Objetivos de esta Gu\u00eda Comprender la estructura interna de un sistema Linux. Aprender c\u00f3mo construir una distribuci\u00f3n Linux embebida desde cero. Entender el papel de cada componente: kernel, bootloader, root filesystem y toolchain. Desarrollar buenas pr\u00e1cticas de compilaci\u00f3n cruzada y personalizaci\u00f3n de im\u00e1genes. Guiar en la creaci\u00f3n de un sistema estable, minimalista y adecuado para hardware espec\u00edfico. Contenido Principal Fundamentos de Linux \u00bfQu\u00e9 es Linux y c\u00f3mo funciona? Componentes principales de un sistema Linux: Kernel: n\u00facleo del sistema operativo. Userland: utilidades b\u00e1sicas y bibliotecas. Init System: proceso de arranque y gesti\u00f3n de servicios. Filesystem: estructura de directorios y jerarqu\u00eda FHS (Filesystem Hierarchy Standard). Diferencias entre Linux de escritorio y Linux embebido. Construcci\u00f3n de un Sistema Embebido Elecci\u00f3n del hardware (SBCs, SoCs y arquitecturas soportadas). Preparaci\u00f3n del toolchain para compilaci\u00f3n cruzada. Compilaci\u00f3n y configuraci\u00f3n del kernel de Linux. Construcci\u00f3n del root filesystem (rootfs). Integraci\u00f3n de bootloader (U-Boot, Barebox, etc.). Empaquetado y generaci\u00f3n de im\u00e1genes (ext4, squashfs, initramfs). Personalizaci\u00f3n y Optimizaci\u00f3n A\u00f1adir controladores (drivers) y m\u00f3dulos necesarios. Configuraci\u00f3n del sistema de inicio (systemd, BusyBox init, etc.). Reducci\u00f3n de tama\u00f1o y optimizaci\u00f3n para dispositivos con recursos limitados. A\u00f1adir aplicaciones y scripts personalizados. Seguridad y actualizaci\u00f3n del sistema. Distribuci\u00f3n y Automatizaci\u00f3n Generaci\u00f3n de im\u00e1genes reproducibles. Uso de herramientas modernas: Buildroot, Yocto Project o compilaci\u00f3n manual. Automatizaci\u00f3n del proceso de construcci\u00f3n con scripts y CI/CD. Testing y validaci\u00f3n en hardware real o emulado (QEMU). C\u00f3mo Usar esta Gu\u00eda 1.- Principiantes : Comienza con los fundamentos de Linux y la arquitectura b\u00e1sica de un sistema embebido. 2.- Intermedios : Aprende a compilar el kernel, rootfs y bootloader. 3.- Avanzados : Crea una distribuci\u00f3n propia automatizada, con soporte para actualizaci\u00f3n OTA y herramientas personalizadas. Requisitos Previos Conocimientos s\u00f3lidos de C y l\u00ednea de comandos en Linux. Comprensi\u00f3n b\u00e1sica de sistemas operativos. Familiaridad con conceptos de compilaci\u00f3n cruzada. Opcional: experiencia con hardware embebido (Raspberry Pi, Orange Pi, STM32MP, etc.). Pr\u00f3ximos Pasos En las siguientes secciones aprender\u00e1s a: Preparar un entorno de compilaci\u00f3n cruzada. Configurar y compilar tu propio kernel de Linux. Construir un root filesystem desde cero. Integrar todo en una imagen lista para ejecutar en tu dispositivo. Este es el punto de partida para crear tu propia distribuci\u00f3n Linux embebida profesional.","title":"Gu\u00eda de Desarrollo de Linux Embebido"},{"location":"linux-development/#guia-completa-para-crear-tu-propia-distribucion-linux-embebido","text":"","title":"Gu\u00eda completa para crear tu propia distribuci\u00f3n Linux Embebido"},{"location":"linux-development/#introduccion","text":"Crear tu propia distribuci\u00f3n Linux embebida es una de las formas m\u00e1s efectivas de comprender c\u00f3mo funciona realmente el sistema operativo Linux. Esta gu\u00eda est\u00e1 dise\u00f1ada para llevarte paso a paso desde los fundamentos del sistema hasta la creaci\u00f3n de una imagen funcional personalizada, adaptada a hardware espec\u00edfico o a un prop\u00f3sito determinado (como kioskos, c\u00e1maras inteligentes o controladores industriales). A lo largo de esta gu\u00eda aprender\u00e1s c\u00f3mo est\u00e1 compuesto Linux, c\u00f3mo se construye desde cero y c\u00f3mo integrarlo en un entorno embebido optimizado y confiable.","title":"Introducci\u00f3n"},{"location":"linux-development/#objetivos-de-esta-guia","text":"Comprender la estructura interna de un sistema Linux. Aprender c\u00f3mo construir una distribuci\u00f3n Linux embebida desde cero. Entender el papel de cada componente: kernel, bootloader, root filesystem y toolchain. Desarrollar buenas pr\u00e1cticas de compilaci\u00f3n cruzada y personalizaci\u00f3n de im\u00e1genes. Guiar en la creaci\u00f3n de un sistema estable, minimalista y adecuado para hardware espec\u00edfico.","title":"Objetivos de esta Gu\u00eda"},{"location":"linux-development/#contenido-principal","text":"","title":"Contenido Principal"},{"location":"linux-development/#fundamentos-de-linux","text":"\u00bfQu\u00e9 es Linux y c\u00f3mo funciona? Componentes principales de un sistema Linux: Kernel: n\u00facleo del sistema operativo. Userland: utilidades b\u00e1sicas y bibliotecas. Init System: proceso de arranque y gesti\u00f3n de servicios. Filesystem: estructura de directorios y jerarqu\u00eda FHS (Filesystem Hierarchy Standard). Diferencias entre Linux de escritorio y Linux embebido.","title":"Fundamentos de Linux"},{"location":"linux-development/#construccion-de-un-sistema-embebido","text":"Elecci\u00f3n del hardware (SBCs, SoCs y arquitecturas soportadas). Preparaci\u00f3n del toolchain para compilaci\u00f3n cruzada. Compilaci\u00f3n y configuraci\u00f3n del kernel de Linux. Construcci\u00f3n del root filesystem (rootfs). Integraci\u00f3n de bootloader (U-Boot, Barebox, etc.). Empaquetado y generaci\u00f3n de im\u00e1genes (ext4, squashfs, initramfs).","title":"Construcci\u00f3n de un Sistema Embebido"},{"location":"linux-development/#personalizacion-y-optimizacion","text":"A\u00f1adir controladores (drivers) y m\u00f3dulos necesarios. Configuraci\u00f3n del sistema de inicio (systemd, BusyBox init, etc.). Reducci\u00f3n de tama\u00f1o y optimizaci\u00f3n para dispositivos con recursos limitados. A\u00f1adir aplicaciones y scripts personalizados.","title":"Personalizaci\u00f3n y Optimizaci\u00f3n"},{"location":"linux-development/#seguridad-y-actualizacion-del-sistema","text":"Distribuci\u00f3n y Automatizaci\u00f3n Generaci\u00f3n de im\u00e1genes reproducibles.","title":"Seguridad y actualizaci\u00f3n del sistema."},{"location":"linux-development/#uso-de-herramientas-modernas-buildroot-yocto-project-o-compilacion-manual","text":"Automatizaci\u00f3n del proceso de construcci\u00f3n con scripts y CI/CD. Testing y validaci\u00f3n en hardware real o emulado (QEMU).","title":"Uso de herramientas modernas: Buildroot, Yocto Project o compilaci\u00f3n manual."},{"location":"linux-development/#como-usar-esta-guia","text":"1.- Principiantes : Comienza con los fundamentos de Linux y la arquitectura b\u00e1sica de un sistema embebido. 2.- Intermedios : Aprende a compilar el kernel, rootfs y bootloader. 3.- Avanzados : Crea una distribuci\u00f3n propia automatizada, con soporte para actualizaci\u00f3n OTA y herramientas personalizadas.","title":"C\u00f3mo Usar esta Gu\u00eda"},{"location":"linux-development/#requisitos-previos","text":"Conocimientos s\u00f3lidos de C y l\u00ednea de comandos en Linux. Comprensi\u00f3n b\u00e1sica de sistemas operativos. Familiaridad con conceptos de compilaci\u00f3n cruzada. Opcional: experiencia con hardware embebido (Raspberry Pi, Orange Pi, STM32MP, etc.).","title":"Requisitos Previos"},{"location":"linux-development/#proximos-pasos","text":"En las siguientes secciones aprender\u00e1s a: Preparar un entorno de compilaci\u00f3n cruzada. Configurar y compilar tu propio kernel de Linux. Construir un root filesystem desde cero. Integrar todo en una imagen lista para ejecutar en tu dispositivo. Este es el punto de partida para crear tu propia distribuci\u00f3n Linux embebida profesional.","title":"Pr\u00f3ximos Pasos"},{"location":"linux-development/linux-kernel-trees/","text":"Estructura y Gesti\u00f3n de Ramas en el Kernel de Linux Breve resumen - El kernel tiene varias ramas con roles claros: la rama principal (mainline) donde Linus integra los cambios, linux-next como integrador de parches de subsistemas, ramas de lanzamiento (rc), ramas stable para correcciones y ramas longterm (LTS) para soporte prolongado. Adem\u00e1s hay ramas t\u00f3picas/por subsistema (topic/ , for-next/ ) donde se preparan conjuntos de parches. Flujo t\u00edpico (resumen) 1. Desarrolladores env\u00edan parches a ramas topic/subsystem. 2. Los mantenedores consolidan y env\u00edan a for-next / topic/* . 3. linux-next integra ramas de subsistema para pruebas. 4. Linus mergea desde linux-next a main y crea release candidates ( vX.Y-rcN ). 5. Tras el lanzamiento, cambios cr\u00edticos se aplican a stable/vX.Y . 6. Algunas versiones se marcan longterm para parches a largo plazo. gitGraph commit id: \"v6.5\" tag: \"v6.5\" branch linux-next commit id: \"merge-integration\" branch for-next commit id: \"subsys-merge\" checkout linux-next merge for-next checkout main merge linux-next commit id: \"v6.6-rc1\" tag: \"v6.6-rc1\" branch stable/v6.x checkout stable/v6.x commit id: \"stable-fix\" checkout main branch longterm/v5.x commit id: \"lts-fix\" checkout longterm/v5.x commit id: \"lts-backport\" checkout main branch topic/driver-x commit id: \"driver-x\" checkout linux-next merge topic/driver-x","title":"Estructura de ramas para el kernel de linux"},{"location":"linux-development/linux-kernel-trees/#estructura-y-gestion-de-ramas-en-el-kernel-de-linux","text":"Breve resumen - El kernel tiene varias ramas con roles claros: la rama principal (mainline) donde Linus integra los cambios, linux-next como integrador de parches de subsistemas, ramas de lanzamiento (rc), ramas stable para correcciones y ramas longterm (LTS) para soporte prolongado. Adem\u00e1s hay ramas t\u00f3picas/por subsistema (topic/ , for-next/ ) donde se preparan conjuntos de parches. Flujo t\u00edpico (resumen) 1. Desarrolladores env\u00edan parches a ramas topic/subsystem. 2. Los mantenedores consolidan y env\u00edan a for-next / topic/* . 3. linux-next integra ramas de subsistema para pruebas. 4. Linus mergea desde linux-next a main y crea release candidates ( vX.Y-rcN ). 5. Tras el lanzamiento, cambios cr\u00edticos se aplican a stable/vX.Y . 6. Algunas versiones se marcan longterm para parches a largo plazo. gitGraph commit id: \"v6.5\" tag: \"v6.5\" branch linux-next commit id: \"merge-integration\" branch for-next commit id: \"subsys-merge\" checkout linux-next merge for-next checkout main merge linux-next commit id: \"v6.6-rc1\" tag: \"v6.6-rc1\" branch stable/v6.x checkout stable/v6.x commit id: \"stable-fix\" checkout main branch longterm/v5.x commit id: \"lts-fix\" checkout longterm/v5.x commit id: \"lts-backport\" checkout main branch topic/driver-x commit id: \"driver-x\" checkout linux-next merge topic/driver-x","title":"Estructura y Gesti\u00f3n de Ramas en el Kernel de Linux"},{"location":"linux-development/linux-kernel/","text":"Guia de compilaci\u00f3n del kernel Linux","title":"Guia de compilaci\u00f3n del kernel Linux"},{"location":"linux-development/linux-kernel/#guia-de-compilacion-del-kernel-linux","text":"","title":"Guia de compilaci\u00f3n del kernel Linux"},{"location":"linux-development/linux-rootfs/","text":"Linux Root Filesystem","title":"Linux Root Filesystem"},{"location":"linux-development/linux-rootfs/#linux-root-filesystem","text":"","title":"Linux Root Filesystem"},{"location":"linux-development/orangepi/orangepi-zero3/","text":"Linux Embebido en OrangePi Zero 3 - Allwinner H618 usando Docker En esta gu\u00eda aprenderemos a construir un sistema operativo Linux embebido en un OrangePi Zero 3 utilizando el procesador Allwinner H618 utilizando contenedores de Docker. Primeros pasos Para iniciar asegurate de tener docker instalado ademas de git . Crea un directorio de trabajo llamado linux-dev o el nombre de tu preferencia y cambia al directorio. mkdir linux-dev cd linux-dev A continuaci\u00f3n se enumeran la serie de pasos de desarrollo del proyecto: 1. Descargar repositorios git clone https://github.com/u-boot/u-boot.git --depth 1 git clone https://github.com/ARM-software/arm-trusted-firmware.git --depth 1 git clone -b orange-pi-6.1-sun50iw9 https://github.com/orangepi-xunlong/linux-orangepi.git --depth 1 # O elige la rama orange-pi-5.13-sunxi64 Lista tu directorio para verificar el contenido. # Comando para listar ls Deberias tener algo as\u00ed: arm-trusted-firmware linux-orangepi u-boot 2. Construir las im\u00e1genes Docker docker build -t uboot-builder docker/ docker build -f docker/Dockerfile.kernel -t linux-kernel-dev docker/ 3. Ejecutar contenedor con volumen montado # Opci\u00f3n 1: Contenedor temporal docker run -it --rm -v $PWD:/home/builder uboot-builder bash # Opci\u00f3n 2: Contenedor persistente con uboot-builder docker run -it --name linux-dev --privileged -v $PWD:/home/builder uboot-builder bash # Opci\u00f3n 3: Contenedor persistente con linux-kernel-dev docker run -it --name linux-dev --privileged -v $PWD:/home/builder linux-kernel-dev bash Iniciar el contenedor linux-dev existente Si creaste un contenedor persistente ejecuta este comando, cada que quieras interactuar con el, de lo contrario utiliza la Opci\u00f3n 1 del paso anterior. docker start -ai linux-dev Cada que cierres o apagues el contenedor deberas iniciarlo como vimos anteriormente, los siguientes pasos se deben ejecutar cuando estes dentro de la instancia del contenedor de docker. 4. Compilaci\u00f3n del bootloader Compilar ARM Trusted Firmware (ATF) Entra a la carpeta arm-trusted-firmware y compila el proyecto. cd arm-trusted-firmware # Ejecuta make <argumentos de entorno ej. PLAT= > <binario a generar Ej. bl13> make PLAT=sun50i_h616 bl31 Esto generara un archivo en esta ruta build/sun50i_h616/release/bl31.bin . Copiar bl31.bin a la ra\u00edz de U-Boot cp build/sun50i_h616/release/bl31.bin ../u-boot/ Este paso es necesario para que no existan errores al compilar el U-Boot. Compilar U-Boot Si estas en la carpeta arm-trusted-firmware ve hacia atr\u00e1s y entra en la carpeta u-boot . # Salir de la carpeta anterior y entrar a u-boot cd ../u-boot # Compilar U-Boot make orangepi_zero3_defconfig make -j$(nproc) CROSS_COMPILE=aarch64-linux-gnu- 5. Grabar en la tarjeta SD A continuaci\u00f3n presione ctrl + d para salir de tu contenedor, esto te dejar\u00e1 en la carpeta ra\u00edz de tu proyecto, asegurate de ingresar de nuevo a la carpeta u-boot y desde la terminal de tu computadora ejecuta el siguiente comando para grabar el binario que compilamos en tu tarjeta SD. En la opci\u00f3n of=/dev/sdx cambia por la ruta de tu dispositivo real, ejemplo: of=/dev/sdb Advertencia \u26a0\ufe0f Ten cuidado con este paso. Podr\u00edas dejar inutilizada tu PC si eliges el dispositivo equivocado. sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdx bs=1024 seek=8 status=progress sync 6. Debug y comunicaci\u00f3n serial Verificar el dispositivo USB-Serial sudo dmesg | grep -i tty Salida esperada: usb 3-2: ch341-uart converter now attached to ttyUSB0 Nota La salida puede variar porque el dispositivo USB-Serial puede tener diferentes nombres en diferentes sistemas. Conectar por serial sudo screen /dev/ttyUSB0 115200 Conecta la placa a la corriente y si todo sali\u00f3 bien deberias darte algo parecido a la siguiente salida por terminal. Ahora si ya tenemos el bootlader grabado y funcional en nuestra SD. Para salir de screen: Ctrl + A , luego k . 7. Compilaci\u00f3n del kernel Configurar el kernel Para la compilacion del kernel ingresamos a la carpeta linux-orangepi , el siguiente paso es descargar un archivo de configuraci\u00f3n que necesitamos para el kernel, asi que nos dirigimos a la siguiente ruta arch/arm64/configs . cd arch/arm64/configs Estando dentro descargamos la configuracion: wget https://raw.githubusercontent.com/orangepi-xunlong/orangepi-build/refs/heads/next/external/config/kernel/linux-6.1-sun50iw9-next.config Renombramos el archivo como una defconfig. mv linux-6.1-sun50iw9-next.config sun50iw9_defconfig Y volvemos a nuestra ruta inicial del kernel. Iniciando la compilaci\u00f3n Volvemos a nuestro proyecto ra\u00edz e ingresamos al contenedor, y desde ah\u00ed ingresamos de nuevo al proyecto linux-orangepi y compilamos la configuraci\u00f3n del kernel. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- sun50iw9_defconfig Opcional compilamos el menuconfig para ver los parametros. # Para compilar y ver el menuconfig (Opcional) make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig Compilar el kernel Inciamos la compilaci\u00f3n del kernel, esto podria demorar algunos minutos o 1 hora dependiendo de los recursos de tu PC. Con este comando compilamos todos los recursos como el kernel, los modulos, y los devices trees. make -j$(nproc) ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Si la compilaci\u00f3n se realiz\u00f3 exitosamente tendremos la imagen del kernel dentro de la carpeta arch/arm64/boot con el nombre de Image , y los devices trees compilados estaran en la carpeta arch/arm64/boot/dts/allwinner los archivos tendr\u00e1n la extensi\u00f3n .dtb . Pr\u00f3ximos Pasos En la siguiente secci\u00f3n seguiremos con la segunda parte del proyecto la cual consiste en construir el rootfs sistema de archivos principal de nuestro sistema Linux Embebido.","title":"Primera parte de Linux embebido en Orange Pi Zero 3"},{"location":"linux-development/orangepi/orangepi-zero3/#linux-embebido-en-orangepi-zero-3-allwinner-h618-usando-docker","text":"En esta gu\u00eda aprenderemos a construir un sistema operativo Linux embebido en un OrangePi Zero 3 utilizando el procesador Allwinner H618 utilizando contenedores de Docker.","title":"Linux Embebido en OrangePi Zero 3 - Allwinner H618 usando Docker"},{"location":"linux-development/orangepi/orangepi-zero3/#primeros-pasos","text":"Para iniciar asegurate de tener docker instalado ademas de git . Crea un directorio de trabajo llamado linux-dev o el nombre de tu preferencia y cambia al directorio. mkdir linux-dev cd linux-dev A continuaci\u00f3n se enumeran la serie de pasos de desarrollo del proyecto:","title":"Primeros pasos"},{"location":"linux-development/orangepi/orangepi-zero3/#1-descargar-repositorios","text":"git clone https://github.com/u-boot/u-boot.git --depth 1 git clone https://github.com/ARM-software/arm-trusted-firmware.git --depth 1 git clone -b orange-pi-6.1-sun50iw9 https://github.com/orangepi-xunlong/linux-orangepi.git --depth 1 # O elige la rama orange-pi-5.13-sunxi64 Lista tu directorio para verificar el contenido. # Comando para listar ls Deberias tener algo as\u00ed: arm-trusted-firmware linux-orangepi u-boot","title":"1. Descargar repositorios"},{"location":"linux-development/orangepi/orangepi-zero3/#2-construir-las-imagenes-docker","text":"docker build -t uboot-builder docker/ docker build -f docker/Dockerfile.kernel -t linux-kernel-dev docker/","title":"2. Construir las im\u00e1genes Docker"},{"location":"linux-development/orangepi/orangepi-zero3/#3-ejecutar-contenedor-con-volumen-montado","text":"# Opci\u00f3n 1: Contenedor temporal docker run -it --rm -v $PWD:/home/builder uboot-builder bash # Opci\u00f3n 2: Contenedor persistente con uboot-builder docker run -it --name linux-dev --privileged -v $PWD:/home/builder uboot-builder bash # Opci\u00f3n 3: Contenedor persistente con linux-kernel-dev docker run -it --name linux-dev --privileged -v $PWD:/home/builder linux-kernel-dev bash","title":"3. Ejecutar contenedor con volumen montado"},{"location":"linux-development/orangepi/orangepi-zero3/#iniciar-el-contenedor-linux-dev-existente","text":"Si creaste un contenedor persistente ejecuta este comando, cada que quieras interactuar con el, de lo contrario utiliza la Opci\u00f3n 1 del paso anterior. docker start -ai linux-dev Cada que cierres o apagues el contenedor deberas iniciarlo como vimos anteriormente, los siguientes pasos se deben ejecutar cuando estes dentro de la instancia del contenedor de docker.","title":"Iniciar el contenedor linux-dev existente"},{"location":"linux-development/orangepi/orangepi-zero3/#4-compilacion-del-bootloader","text":"","title":"4. Compilaci\u00f3n del bootloader"},{"location":"linux-development/orangepi/orangepi-zero3/#compilar-arm-trusted-firmware-atf","text":"Entra a la carpeta arm-trusted-firmware y compila el proyecto. cd arm-trusted-firmware # Ejecuta make <argumentos de entorno ej. PLAT= > <binario a generar Ej. bl13> make PLAT=sun50i_h616 bl31 Esto generara un archivo en esta ruta build/sun50i_h616/release/bl31.bin .","title":"Compilar ARM Trusted Firmware (ATF)"},{"location":"linux-development/orangepi/orangepi-zero3/#copiar-bl31bin-a-la-raiz-de-u-boot","text":"cp build/sun50i_h616/release/bl31.bin ../u-boot/ Este paso es necesario para que no existan errores al compilar el U-Boot.","title":"Copiar bl31.bin a la ra\u00edz de U-Boot"},{"location":"linux-development/orangepi/orangepi-zero3/#compilar-u-boot","text":"Si estas en la carpeta arm-trusted-firmware ve hacia atr\u00e1s y entra en la carpeta u-boot . # Salir de la carpeta anterior y entrar a u-boot cd ../u-boot # Compilar U-Boot make orangepi_zero3_defconfig make -j$(nproc) CROSS_COMPILE=aarch64-linux-gnu-","title":"Compilar U-Boot"},{"location":"linux-development/orangepi/orangepi-zero3/#5-grabar-en-la-tarjeta-sd","text":"A continuaci\u00f3n presione ctrl + d para salir de tu contenedor, esto te dejar\u00e1 en la carpeta ra\u00edz de tu proyecto, asegurate de ingresar de nuevo a la carpeta u-boot y desde la terminal de tu computadora ejecuta el siguiente comando para grabar el binario que compilamos en tu tarjeta SD. En la opci\u00f3n of=/dev/sdx cambia por la ruta de tu dispositivo real, ejemplo: of=/dev/sdb Advertencia \u26a0\ufe0f Ten cuidado con este paso. Podr\u00edas dejar inutilizada tu PC si eliges el dispositivo equivocado. sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdx bs=1024 seek=8 status=progress sync","title":"5. Grabar en la tarjeta SD"},{"location":"linux-development/orangepi/orangepi-zero3/#6-debug-y-comunicacion-serial","text":"","title":"6. Debug y comunicaci\u00f3n serial"},{"location":"linux-development/orangepi/orangepi-zero3/#verificar-el-dispositivo-usb-serial","text":"sudo dmesg | grep -i tty Salida esperada: usb 3-2: ch341-uart converter now attached to ttyUSB0 Nota La salida puede variar porque el dispositivo USB-Serial puede tener diferentes nombres en diferentes sistemas.","title":"Verificar el dispositivo USB-Serial"},{"location":"linux-development/orangepi/orangepi-zero3/#conectar-por-serial","text":"sudo screen /dev/ttyUSB0 115200 Conecta la placa a la corriente y si todo sali\u00f3 bien deberias darte algo parecido a la siguiente salida por terminal. Ahora si ya tenemos el bootlader grabado y funcional en nuestra SD. Para salir de screen: Ctrl + A , luego k .","title":"Conectar por serial"},{"location":"linux-development/orangepi/orangepi-zero3/#7-compilacion-del-kernel","text":"","title":"7. Compilaci\u00f3n del kernel"},{"location":"linux-development/orangepi/orangepi-zero3/#configurar-el-kernel","text":"Para la compilacion del kernel ingresamos a la carpeta linux-orangepi , el siguiente paso es descargar un archivo de configuraci\u00f3n que necesitamos para el kernel, asi que nos dirigimos a la siguiente ruta arch/arm64/configs . cd arch/arm64/configs Estando dentro descargamos la configuracion: wget https://raw.githubusercontent.com/orangepi-xunlong/orangepi-build/refs/heads/next/external/config/kernel/linux-6.1-sun50iw9-next.config Renombramos el archivo como una defconfig. mv linux-6.1-sun50iw9-next.config sun50iw9_defconfig Y volvemos a nuestra ruta inicial del kernel.","title":"Configurar el kernel"},{"location":"linux-development/orangepi/orangepi-zero3/#iniciando-la-compilacion","text":"Volvemos a nuestro proyecto ra\u00edz e ingresamos al contenedor, y desde ah\u00ed ingresamos de nuevo al proyecto linux-orangepi y compilamos la configuraci\u00f3n del kernel. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- sun50iw9_defconfig Opcional compilamos el menuconfig para ver los parametros. # Para compilar y ver el menuconfig (Opcional) make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig","title":"Iniciando la compilaci\u00f3n"},{"location":"linux-development/orangepi/orangepi-zero3/#compilar-el-kernel","text":"Inciamos la compilaci\u00f3n del kernel, esto podria demorar algunos minutos o 1 hora dependiendo de los recursos de tu PC. Con este comando compilamos todos los recursos como el kernel, los modulos, y los devices trees. make -j$(nproc) ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Si la compilaci\u00f3n se realiz\u00f3 exitosamente tendremos la imagen del kernel dentro de la carpeta arch/arm64/boot con el nombre de Image , y los devices trees compilados estaran en la carpeta arch/arm64/boot/dts/allwinner los archivos tendr\u00e1n la extensi\u00f3n .dtb .","title":"Compilar el kernel"},{"location":"linux-development/orangepi/orangepi-zero3/#proximos-pasos","text":"En la siguiente secci\u00f3n seguiremos con la segunda parte del proyecto la cual consiste en construir el rootfs sistema de archivos principal de nuestro sistema Linux Embebido.","title":"Pr\u00f3ximos Pasos"},{"location":"linux-development/orangepi/resources/","text":"Recursos del proyecto","title":"Recursos del proyecto"},{"location":"linux-development/orangepi/resources/#recursos-del-proyecto","text":"","title":"Recursos del proyecto"},{"location":"linux-development/orangepi/rootfs/","text":"Segunda parte del proyecto Linux Embebido en OrangePi Zero 3 - Allwinner H618 usando Docker Aqui se continuar\u00e1 con la guia de desarrollo de Linux Embebido en la OrangePi Zero 3, en la secci\u00f3n anterior preparamos el entorno de trabajo y compilamos los dos primeros componentes del sistema: U-Boot (bootloader) Kernel de Linux En esta ocasi\u00f3n nos centraremos en crear un rootfs que ser\u00e1 nuestro sistema de archivos ra\u00edz donde formaremos la arquitectura de directorios convencional de Linux, ya agregremos el sistema de arranque y porgramas b\u00e1sicos apyandonos del proyecto Busybox . Estructura principal Nos dirigeremos a nuestra carpeta principal del proyecto, y crearemos el directorio ra\u00edz rootfs mkdir -p rootfs Las carpetas se verian asi: arm-trusted-firmware linux-orangepi rootfs u-boot Despues entramos a este nuevo directorio. cd rootfs Creamos la estructura de directorios mkdir -p {dev,proc,sys,etc,bin,sbin,tmp,usr/{bin,sbin},var,home} chmod 1777 tmp Creamos dispositivos basicos en dev . Estando dentro de rootfs nos dirigimos a la capeta dev creada en el paso anterior, y ah\u00ed creamos los dispositivos principales. cd dev sudo mknod -m 622 console c 5 1 sudo mknod -m 666 null c 1 3 Estos dispositivos son necesarios para el funcionamiento de nuestro sistema, de lo contrario no podr\u00e1 arrancar. Busybox Ahora volvemos a la raiz de nuestro proyecto y descargaremos busybox desde su repositorio. git clone https://github.com/mirror/busybox.git --depth 1 cd busybox Esto descargar\u00e1 el proyecto y nos pondr\u00e1 dentro del directorio. El siguiente paso es crear la configuraci\u00f3n. make defconfig make menuconfig Dentro del menu editamos la configuraci\u00f3n, debemos activar la compilaci\u00f3n estatica para no tener problema de dependencias. Settings \u2192 Build static binary (no shared libs) La activamos dando la tecla [space] . Tambien debemos desactivar la opcion de aceleraci\u00f3n SHA1. Salimos y guardamos. Iniciamos la compilaci\u00f3n El proceso puede durar algunos minutos dependiendo de tu maquina. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc) Si el proceso fue exitoso instalamos busybox en nuestro rootfs . Nota Asegurate que la ruta del rootfs sea la correcta, de lo contrario podria no instalarse o crear problemas. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=../rootfs-arm64 modules_install Ahora en nuestro directorio rootfs deberiamos tener instalado busybox, puedes comprobarlo, deberias tener este archivo. rootfs/bin/busybox Creando el Init Dentro de tu rootfs , crea un archivo init en la raiz principal. cd rootfs touch init Ahora abrimos con el editor este archivo y agregamos el siguiente contenido inicial. #!/bin/sh # Montar sistemas de archivos necesarios mount -t proc proc /proc mount -t sysfs sysfs /sys mount -t devtmpfs devtmpfs /dev # Mensaje de inicio echo \"Iniciando sistema...\" # Lanzar shell interactiva exec /bin/sh Este script sera el proceso principal con el cual vamos a interactuar. Hacemos el init ejecutable. chmod +x init Instalando modulos del kernel en el rootfs Nos dirigimos a la carpeta linux-orangepi y ejecutamos el siguiente comando, de la misma manera debemos asegurarnos que la ruta del rootfs sea la correcta make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- modules_install INSTALL_MOD_PATH=../rootfs Pr\u00f3ximos pasos En la siguiente secci\u00f3n veremos como crear la configuracion para el aranque y empaquetar todo para tener nuestro sistema Linux embebido listo para ejecutar en nuestra OrangePi Zero 3.","title":"Segunda parte de Linux embebido en Orange Pi Zero 3"},{"location":"linux-development/orangepi/rootfs/#segunda-parte-del-proyecto-linux-embebido-en-orangepi-zero-3-allwinner-h618-usando-docker","text":"Aqui se continuar\u00e1 con la guia de desarrollo de Linux Embebido en la OrangePi Zero 3, en la secci\u00f3n anterior preparamos el entorno de trabajo y compilamos los dos primeros componentes del sistema: U-Boot (bootloader) Kernel de Linux En esta ocasi\u00f3n nos centraremos en crear un rootfs que ser\u00e1 nuestro sistema de archivos ra\u00edz donde formaremos la arquitectura de directorios convencional de Linux, ya agregremos el sistema de arranque y porgramas b\u00e1sicos apyandonos del proyecto Busybox .","title":"Segunda parte del proyecto Linux Embebido en OrangePi Zero 3 - Allwinner H618 usando Docker"},{"location":"linux-development/orangepi/rootfs/#estructura-principal","text":"Nos dirigeremos a nuestra carpeta principal del proyecto, y crearemos el directorio ra\u00edz rootfs mkdir -p rootfs Las carpetas se verian asi: arm-trusted-firmware linux-orangepi rootfs u-boot Despues entramos a este nuevo directorio. cd rootfs Creamos la estructura de directorios mkdir -p {dev,proc,sys,etc,bin,sbin,tmp,usr/{bin,sbin},var,home} chmod 1777 tmp Creamos dispositivos basicos en dev . Estando dentro de rootfs nos dirigimos a la capeta dev creada en el paso anterior, y ah\u00ed creamos los dispositivos principales. cd dev sudo mknod -m 622 console c 5 1 sudo mknod -m 666 null c 1 3 Estos dispositivos son necesarios para el funcionamiento de nuestro sistema, de lo contrario no podr\u00e1 arrancar.","title":"Estructura principal"},{"location":"linux-development/orangepi/rootfs/#busybox","text":"Ahora volvemos a la raiz de nuestro proyecto y descargaremos busybox desde su repositorio. git clone https://github.com/mirror/busybox.git --depth 1 cd busybox Esto descargar\u00e1 el proyecto y nos pondr\u00e1 dentro del directorio. El siguiente paso es crear la configuraci\u00f3n. make defconfig make menuconfig Dentro del menu editamos la configuraci\u00f3n, debemos activar la compilaci\u00f3n estatica para no tener problema de dependencias. Settings \u2192 Build static binary (no shared libs) La activamos dando la tecla [space] . Tambien debemos desactivar la opcion de aceleraci\u00f3n SHA1. Salimos y guardamos.","title":"Busybox"},{"location":"linux-development/orangepi/rootfs/#iniciamos-la-compilacion","text":"El proceso puede durar algunos minutos dependiendo de tu maquina. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc) Si el proceso fue exitoso instalamos busybox en nuestro rootfs . Nota Asegurate que la ruta del rootfs sea la correcta, de lo contrario podria no instalarse o crear problemas. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=../rootfs-arm64 modules_install Ahora en nuestro directorio rootfs deberiamos tener instalado busybox, puedes comprobarlo, deberias tener este archivo. rootfs/bin/busybox","title":"Iniciamos la compilaci\u00f3n"},{"location":"linux-development/orangepi/rootfs/#creando-el-init","text":"Dentro de tu rootfs , crea un archivo init en la raiz principal. cd rootfs touch init Ahora abrimos con el editor este archivo y agregamos el siguiente contenido inicial. #!/bin/sh # Montar sistemas de archivos necesarios mount -t proc proc /proc mount -t sysfs sysfs /sys mount -t devtmpfs devtmpfs /dev # Mensaje de inicio echo \"Iniciando sistema...\" # Lanzar shell interactiva exec /bin/sh Este script sera el proceso principal con el cual vamos a interactuar. Hacemos el init ejecutable. chmod +x init","title":"Creando el Init"},{"location":"linux-development/orangepi/rootfs/#instalando-modulos-del-kernel-en-el-rootfs","text":"Nos dirigimos a la carpeta linux-orangepi y ejecutamos el siguiente comando, de la misma manera debemos asegurarnos que la ruta del rootfs sea la correcta make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- modules_install INSTALL_MOD_PATH=../rootfs","title":"Instalando modulos del kernel en el rootfs"},{"location":"linux-development/orangepi/rootfs/#proximos-pasos","text":"En la siguiente secci\u00f3n veremos como crear la configuracion para el aranque y empaquetar todo para tener nuestro sistema Linux embebido listo para ejecutar en nuestra OrangePi Zero 3.","title":"Pr\u00f3ximos pasos"},{"location":"rup/","text":"Rational Unified Process (RUP) Rational Unified Process (RUP) , o Proceso Unificado de Rational, es un enfoque metodol\u00f3gico para el desarrollo de software que proporciona una estructura y gu\u00eda para gestionar todo el ciclo de vida del desarrollo de software. RUP busca producir software de alta calidad de manera predecible y controlada. RUP se organiza en cinco etapas principales , que ayudan a planificar, dise\u00f1ar, implementar y validar el software de manera iterativa y progresiva. 1. Inicio (Inception) La fase de Inicio se centra en definir el alcance del proyecto y sus objetivos principales. En esta etapa se realizan actividades como: Identificaci\u00f3n de los requisitos m\u00e1s importantes. Definici\u00f3n de los actores principales y casos de uso. Evaluaci\u00f3n de riesgos iniciales. Estimaci\u00f3n de recursos, costos y tiempos. Creaci\u00f3n de un plan de proyecto preliminar. El objetivo principal de esta fase es asegurar que el proyecto es viable y que los stakeholders est\u00e1n alineados . 2. Elaboraci\u00f3n (Elaboration / An\u00e1lisis) Durante la fase de Elaboraci\u00f3n , se profundiza en los requisitos y se define la arquitectura del sistema. Actividades clave: Refinamiento de requisitos y casos de uso. An\u00e1lisis de riesgos detallado. Dise\u00f1o de la arquitectura b\u00e1sica del software. Preparaci\u00f3n de un plan de desarrollo detallado. Validaci\u00f3n temprana de la viabilidad t\u00e9cnica. Esta fase busca establecer una base s\u00f3lida para el desarrollo y minimizar riesgos futuros . 3. Construcci\u00f3n (Construction / Dise\u00f1o e Implementaci\u00f3n) La fase de Construcci\u00f3n est\u00e1 dedicada a desarrollar y construir el sistema siguiendo la arquitectura definida. Actividades principales: Dise\u00f1o detallado de componentes y m\u00f3dulos. Implementaci\u00f3n del c\u00f3digo fuente. Integraci\u00f3n de componentes. Pruebas unitarias y de integraci\u00f3n. Gesti\u00f3n continua de la configuraci\u00f3n. El objetivo es producir un sistema completo y funcional listo para pruebas m\u00e1s exhaustivas . 4. Pruebas (Transition / Verificaci\u00f3n y Validaci\u00f3n) La fase de Pruebas o Transici\u00f3n se centra en validar que el sistema cumple con los requisitos y est\u00e1 listo para su despliegue . Actividades: Pruebas de aceptaci\u00f3n por el usuario. Correcci\u00f3n de defectos encontrados durante la prueba. Ajustes de rendimiento y optimizaci\u00f3n. Preparaci\u00f3n de la documentaci\u00f3n final del usuario. Capacitaci\u00f3n a usuarios finales si es necesario. Se busca garantizar la calidad y satisfacci\u00f3n del cliente antes del lanzamiento . 5. Mantenimiento (Maintenance) Aunque RUP formalmente tiene cuatro fases principales, el mantenimiento es un proceso continuo posterior al despliegue: Correcci\u00f3n de errores encontrados en producci\u00f3n. Mejoras y actualizaciones del sistema. Adaptaci\u00f3n a nuevos requisitos o cambios tecnol\u00f3gicos. Gesti\u00f3n de la configuraci\u00f3n y versiones futuras. El objetivo es mantener el sistema operativo y evolucionar con las necesidades del negocio . Caracter\u00edsticas clave de RUP Iterativo e incremental: El desarrollo se realiza en ciclos, permitiendo ajustes tempranos. Orientado a casos de uso: Los requisitos se documentan como casos de uso que gu\u00edan el desarrollo. Gesti\u00f3n de riesgos: Identificaci\u00f3n y mitigaci\u00f3n de riesgos desde el inicio. Documentaci\u00f3n controlada: RUP define artefactos y plantillas para estandarizar el proceso.","title":"Introducci\u00f3n a RUP"},{"location":"rup/#rational-unified-process-rup","text":"Rational Unified Process (RUP) , o Proceso Unificado de Rational, es un enfoque metodol\u00f3gico para el desarrollo de software que proporciona una estructura y gu\u00eda para gestionar todo el ciclo de vida del desarrollo de software. RUP busca producir software de alta calidad de manera predecible y controlada. RUP se organiza en cinco etapas principales , que ayudan a planificar, dise\u00f1ar, implementar y validar el software de manera iterativa y progresiva.","title":"Rational Unified Process (RUP)"},{"location":"rup/#1-inicio-inception","text":"La fase de Inicio se centra en definir el alcance del proyecto y sus objetivos principales. En esta etapa se realizan actividades como: Identificaci\u00f3n de los requisitos m\u00e1s importantes. Definici\u00f3n de los actores principales y casos de uso. Evaluaci\u00f3n de riesgos iniciales. Estimaci\u00f3n de recursos, costos y tiempos. Creaci\u00f3n de un plan de proyecto preliminar. El objetivo principal de esta fase es asegurar que el proyecto es viable y que los stakeholders est\u00e1n alineados .","title":"1. Inicio (Inception)"},{"location":"rup/#2-elaboracion-elaboration-analisis","text":"Durante la fase de Elaboraci\u00f3n , se profundiza en los requisitos y se define la arquitectura del sistema. Actividades clave: Refinamiento de requisitos y casos de uso. An\u00e1lisis de riesgos detallado. Dise\u00f1o de la arquitectura b\u00e1sica del software. Preparaci\u00f3n de un plan de desarrollo detallado. Validaci\u00f3n temprana de la viabilidad t\u00e9cnica. Esta fase busca establecer una base s\u00f3lida para el desarrollo y minimizar riesgos futuros .","title":"2. Elaboraci\u00f3n (Elaboration / An\u00e1lisis)"},{"location":"rup/#3-construccion-construction-diseno-e-implementacion","text":"La fase de Construcci\u00f3n est\u00e1 dedicada a desarrollar y construir el sistema siguiendo la arquitectura definida. Actividades principales: Dise\u00f1o detallado de componentes y m\u00f3dulos. Implementaci\u00f3n del c\u00f3digo fuente. Integraci\u00f3n de componentes. Pruebas unitarias y de integraci\u00f3n. Gesti\u00f3n continua de la configuraci\u00f3n. El objetivo es producir un sistema completo y funcional listo para pruebas m\u00e1s exhaustivas .","title":"3. Construcci\u00f3n (Construction / Dise\u00f1o e Implementaci\u00f3n)"},{"location":"rup/#4-pruebas-transition-verificacion-y-validacion","text":"La fase de Pruebas o Transici\u00f3n se centra en validar que el sistema cumple con los requisitos y est\u00e1 listo para su despliegue . Actividades: Pruebas de aceptaci\u00f3n por el usuario. Correcci\u00f3n de defectos encontrados durante la prueba. Ajustes de rendimiento y optimizaci\u00f3n. Preparaci\u00f3n de la documentaci\u00f3n final del usuario. Capacitaci\u00f3n a usuarios finales si es necesario. Se busca garantizar la calidad y satisfacci\u00f3n del cliente antes del lanzamiento .","title":"4. Pruebas (Transition / Verificaci\u00f3n y Validaci\u00f3n)"},{"location":"rup/#5-mantenimiento-maintenance","text":"Aunque RUP formalmente tiene cuatro fases principales, el mantenimiento es un proceso continuo posterior al despliegue: Correcci\u00f3n de errores encontrados en producci\u00f3n. Mejoras y actualizaciones del sistema. Adaptaci\u00f3n a nuevos requisitos o cambios tecnol\u00f3gicos. Gesti\u00f3n de la configuraci\u00f3n y versiones futuras. El objetivo es mantener el sistema operativo y evolucionar con las necesidades del negocio .","title":"5. Mantenimiento (Maintenance)"},{"location":"rup/#caracteristicas-clave-de-rup","text":"Iterativo e incremental: El desarrollo se realiza en ciclos, permitiendo ajustes tempranos. Orientado a casos de uso: Los requisitos se documentan como casos de uso que gu\u00edan el desarrollo. Gesti\u00f3n de riesgos: Identificaci\u00f3n y mitigaci\u00f3n de riesgos desde el inicio. Documentaci\u00f3n controlada: RUP define artefactos y plantillas para estandarizar el proceso.","title":"Caracter\u00edsticas clave de RUP"},{"location":"rup/phases/","text":"Fases de Rational Unified Process (RUP) Introducci\u00f3n Rational Unified Process (RUP) es una metodolog\u00eda de desarrollo de software que organiza el ciclo de vida del proyecto en cuatro fases principales. Cada fase tiene objetivos espec\u00edficos y entregables definidos. Las Cuatro Fases de RUP 1. Fase de Inicio (Inception) Objetivo: Establecer la viabilidad del proyecto y definir el alcance inicial. Actividades principales: - Identificaci\u00f3n de los actores y casos de uso principales - Evaluaci\u00f3n de riesgos cr\u00edticos - Estimaci\u00f3n preliminar de costos y cronograma - Definici\u00f3n de la arquitectura candidata - Establecimiento del caso de negocio Entregables: - Documento de visi\u00f3n - Modelo de casos de uso inicial - Glosario del proyecto - Plan de desarrollo de software - Prototipo de la arquitectura 2. Fase de Elaboraci\u00f3n (Elaboration) Objetivo: Establecer una l\u00ednea base s\u00f3lida de la arquitectura del sistema y mitigar los riesgos principales. Actividades principales: - Refinamiento de la visi\u00f3n del producto - Establecimiento de la arquitectura base - Eliminaci\u00f3n de los riesgos de mayor prioridad - Refinamiento del plan de desarrollo - Desarrollo de un prototipo ejecutable Entregables: - Modelo de casos de uso completo al 80% - Descripci\u00f3n de la arquitectura de software - Prototipo arquitect\u00f3nico ejecutable - Lista de riesgos revisada - Plan de desarrollo refinado 3. Fase de Construcci\u00f3n (Construction) Objetivo: Completar el desarrollo del sistema basado en la arquitectura establecida. Actividades principales: - Desarrollo iterativo del producto completo - Minimizaci\u00f3n de costos de desarrollo - Logro de calidad adecuada lo m\u00e1s r\u00e1pidamente posible - Desarrollo de versiones operativas del producto - Finalizaci\u00f3n de an\u00e1lisis, dise\u00f1o, implementaci\u00f3n y pruebas Entregables: - Producto de software integrado y ejecutado - Modelo de implementaci\u00f3n - Modelo de datos - Material de soporte al usuario final - Descripci\u00f3n de la release actual 4. Fase de Transici\u00f3n (Transition) Objetivo: Poner el producto en manos de los usuarios finales. Actividades principales: - Pruebas beta para validar el nuevo sistema - Entrenamiento de usuarios y mantenedores - Conversi\u00f3n de bases de datos operacionales - Instalaci\u00f3n del producto en el entorno de producci\u00f3n - Soporte y mantenimiento Entregables: - Producto de software empaquetado - Material de entrenamiento - Documentaci\u00f3n de usuario - Documentaci\u00f3n de soporte - Lecciones aprendidas del proyecto Caracter\u00edsticas Clave de las Fases Iterativo e Incremental Cada fase contiene m\u00faltiples iteraciones que producen incrementos del producto. Hitos (Milestones) Objetivos del Ciclo de Vida (fin de Inicio) Arquitectura del Ciclo de Vida (fin de Elaboraci\u00f3n) Capacidad Operacional Inicial (fin de Construcci\u00f3n) Release del Producto (fin de Transici\u00f3n) Distribuci\u00f3n del Esfuerzo Inicio: 5-10% del esfuerzo total Elaboraci\u00f3n: 15-20% del esfuerzo total Construcci\u00f3n: 65-75% del esfuerzo total Transici\u00f3n: 10-15% del esfuerzo total Conclusi\u00f3n Las fases de RUP proporcionan un marco estructurado para el desarrollo de software, permitiendo una gesti\u00f3n efectiva de riesgos y una entrega incremental de valor al cliente. La naturaleza iterativa de cada fase facilita la adaptaci\u00f3n a cambios y la mejora continua del proceso de desarrollo.","title":"Fases del proceso"},{"location":"rup/phases/#fases-de-rational-unified-process-rup","text":"","title":"Fases de Rational Unified Process (RUP)"},{"location":"rup/phases/#introduccion","text":"Rational Unified Process (RUP) es una metodolog\u00eda de desarrollo de software que organiza el ciclo de vida del proyecto en cuatro fases principales. Cada fase tiene objetivos espec\u00edficos y entregables definidos.","title":"Introducci\u00f3n"},{"location":"rup/phases/#las-cuatro-fases-de-rup","text":"","title":"Las Cuatro Fases de RUP"},{"location":"rup/phases/#1-fase-de-inicio-inception","text":"Objetivo: Establecer la viabilidad del proyecto y definir el alcance inicial. Actividades principales: - Identificaci\u00f3n de los actores y casos de uso principales - Evaluaci\u00f3n de riesgos cr\u00edticos - Estimaci\u00f3n preliminar de costos y cronograma - Definici\u00f3n de la arquitectura candidata - Establecimiento del caso de negocio Entregables: - Documento de visi\u00f3n - Modelo de casos de uso inicial - Glosario del proyecto - Plan de desarrollo de software - Prototipo de la arquitectura","title":"1. Fase de Inicio (Inception)"},{"location":"rup/phases/#2-fase-de-elaboracion-elaboration","text":"Objetivo: Establecer una l\u00ednea base s\u00f3lida de la arquitectura del sistema y mitigar los riesgos principales. Actividades principales: - Refinamiento de la visi\u00f3n del producto - Establecimiento de la arquitectura base - Eliminaci\u00f3n de los riesgos de mayor prioridad - Refinamiento del plan de desarrollo - Desarrollo de un prototipo ejecutable Entregables: - Modelo de casos de uso completo al 80% - Descripci\u00f3n de la arquitectura de software - Prototipo arquitect\u00f3nico ejecutable - Lista de riesgos revisada - Plan de desarrollo refinado","title":"2. Fase de Elaboraci\u00f3n (Elaboration)"},{"location":"rup/phases/#3-fase-de-construccion-construction","text":"Objetivo: Completar el desarrollo del sistema basado en la arquitectura establecida. Actividades principales: - Desarrollo iterativo del producto completo - Minimizaci\u00f3n de costos de desarrollo - Logro de calidad adecuada lo m\u00e1s r\u00e1pidamente posible - Desarrollo de versiones operativas del producto - Finalizaci\u00f3n de an\u00e1lisis, dise\u00f1o, implementaci\u00f3n y pruebas Entregables: - Producto de software integrado y ejecutado - Modelo de implementaci\u00f3n - Modelo de datos - Material de soporte al usuario final - Descripci\u00f3n de la release actual","title":"3. Fase de Construcci\u00f3n (Construction)"},{"location":"rup/phases/#4-fase-de-transicion-transition","text":"Objetivo: Poner el producto en manos de los usuarios finales. Actividades principales: - Pruebas beta para validar el nuevo sistema - Entrenamiento de usuarios y mantenedores - Conversi\u00f3n de bases de datos operacionales - Instalaci\u00f3n del producto en el entorno de producci\u00f3n - Soporte y mantenimiento Entregables: - Producto de software empaquetado - Material de entrenamiento - Documentaci\u00f3n de usuario - Documentaci\u00f3n de soporte - Lecciones aprendidas del proyecto","title":"4. Fase de Transici\u00f3n (Transition)"},{"location":"rup/phases/#caracteristicas-clave-de-las-fases","text":"","title":"Caracter\u00edsticas Clave de las Fases"},{"location":"rup/phases/#iterativo-e-incremental","text":"Cada fase contiene m\u00faltiples iteraciones que producen incrementos del producto.","title":"Iterativo e Incremental"},{"location":"rup/phases/#hitos-milestones","text":"Objetivos del Ciclo de Vida (fin de Inicio) Arquitectura del Ciclo de Vida (fin de Elaboraci\u00f3n) Capacidad Operacional Inicial (fin de Construcci\u00f3n) Release del Producto (fin de Transici\u00f3n)","title":"Hitos (Milestones)"},{"location":"rup/phases/#distribucion-del-esfuerzo","text":"Inicio: 5-10% del esfuerzo total Elaboraci\u00f3n: 15-20% del esfuerzo total Construcci\u00f3n: 65-75% del esfuerzo total Transici\u00f3n: 10-15% del esfuerzo total","title":"Distribuci\u00f3n del Esfuerzo"},{"location":"rup/phases/#conclusion","text":"Las fases de RUP proporcionan un marco estructurado para el desarrollo de software, permitiendo una gesti\u00f3n efectiva de riesgos y una entrega incremental de valor al cliente. La naturaleza iterativa de cada fase facilita la adaptaci\u00f3n a cambios y la mejora continua del proceso de desarrollo.","title":"Conclusi\u00f3n"},{"location":"rup/uml/","text":"Introducci\u00f3n a UML y Diagramas con PlantUML UML (Unified Modeling Language) es un lenguaje gr\u00e1fico estandarizado para visualizar, especificar, construir y documentar sistemas de software. UML permite representar distintos aspectos de un sistema mediante diagramas, que se agrupan en diagramas estructurales y diagramas de comportamiento. A continuaci\u00f3n se incluyen ejemplos pr\u00e1cticos usando PlantUML. 1. Diagramas Estructurales 1.1 Diagrama de Clases @startuml class Usuario { -nombre: String -email: String +login(): boolean +logout(): void } class Producto { -nombre: String -precio: float +comprar(): void } Usuario \"1\" --> \"*\" Producto : compra @enduml 01188c5f1cea91f32063a90a5b8d7a250c00353754fb9895b594e99911810c18667cc7e64c17a33f63ecdad4898550c1b271a29bc8f15567559dab0e727b19ee 1.2 Diagrama de Componentes @startuml package \"Sistema de Ventas\" { [Interfaz Web] --> [Controlador] [Controlador] --> [Servicio de Usuarios] [Controlador] --> [Servicio de Productos] [Servicio de Usuarios] --> [Base de Datos] [Servicio de Productos] --> [Base de Datos] } @enduml e772a08ed061126d842f7f5b3627b1d48ab4f90ccf4f1763b61c8368faa9fe642aa5b3225a47c177bc25a63d1992aa5c1b28abcade31c243b6a731a4bc7b1f05 1.3 Diagrama de Despliegue (Deployment) @startuml node \"Servidor Web\" { [Aplicaci\u00f3n Web] } node \"Servidor DB\" { [Base de Datos] } [Aplicaci\u00f3n Web] --> [Base de Datos] @enduml dc3a0444a916b4fe1482616df3eb598b6c0d675141e595835ab05f12e7eca9d40dc26656849a9b5e7b4832e5b58fe90c3148142966fb626f94cbff8e6be28aa2 2. Diagramas de Comportamiento 2.1 Diagrama de Casos de Uso @startuml actor Cliente actor Administrador Cliente --> (Comprar Producto) Cliente --> (Consultar Producto) Administrador --> (Agregar Producto) Administrador --> (Eliminar Producto) @enduml 5464e521aacdc82ec714b854af81604e675da48472cf07353c11373952322ac7c51e46ba468567c36723ae75c7925d563cac425f66f4ce53f9ed33ee88bb604b 2.2 Diagrama de Secuencia @startuml actor Cliente participant Sistema participant Inventario Cliente -> Sistema : solicitarCompra() Sistema -> Inventario : verificarStock() Inventario --> Sistema : stockDisponible() Sistema --> Cliente : confirmarCompra() @enduml d8d8aab2d540b3794c6bb063cad67e337ecb0203512163903455c7bc44d38a5b458b6133f7ed850220179b31ca28ed87255b7c6a1c3bd1dbe91ce3578528ab62 2.3 Diagrama de Actividad @startuml start :Seleccionar producto; :Agregar al carrito; if (Stock disponible?) then (s\u00ed) :Procesar pago; :Generar factura; else (no) :Mostrar mensaje de error; endif stop @enduml fc6b155e1f2bec5c0ce7b4bd1418302e854a734331f5229e725c95adef1a42205e84b15da4ee53e2afa0ae533e1b99052e4456b6e884154c2337ea66e7dc176d 2.4 Diagrama de Estados @startuml [*] --> Pendiente Pendiente --> Pagado : realizarPago Pagado --> Enviado : enviarProducto Enviado --> Entregado : confirmarEntrega @enduml 80d7bfff776ff6904ec182565abb22a47f6d60c1d9c68be4c82277b7971c43e403b449d0d9cf8f36a17d4f7f9ef4b5c107111a7304b1a7667441a7a8b5d8ca48","title":"UML"},{"location":"rup/uml/#introduccion-a-uml-y-diagramas-con-plantuml","text":"UML (Unified Modeling Language) es un lenguaje gr\u00e1fico estandarizado para visualizar, especificar, construir y documentar sistemas de software. UML permite representar distintos aspectos de un sistema mediante diagramas, que se agrupan en diagramas estructurales y diagramas de comportamiento. A continuaci\u00f3n se incluyen ejemplos pr\u00e1cticos usando PlantUML.","title":"Introducci\u00f3n a UML y Diagramas con PlantUML"},{"location":"rup/uml/#1-diagramas-estructurales","text":"","title":"1. Diagramas Estructurales"},{"location":"rup/uml/#11-diagrama-de-clases","text":"@startuml class Usuario { -nombre: String -email: String +login(): boolean +logout(): void } class Producto { -nombre: String -precio: float +comprar(): void } Usuario \"1\" --> \"*\" Producto : compra @enduml 01188c5f1cea91f32063a90a5b8d7a250c00353754fb9895b594e99911810c18667cc7e64c17a33f63ecdad4898550c1b271a29bc8f15567559dab0e727b19ee","title":"1.1 Diagrama de Clases"},{"location":"rup/uml/#12-diagrama-de-componentes","text":"@startuml package \"Sistema de Ventas\" { [Interfaz Web] --> [Controlador] [Controlador] --> [Servicio de Usuarios] [Controlador] --> [Servicio de Productos] [Servicio de Usuarios] --> [Base de Datos] [Servicio de Productos] --> [Base de Datos] } @enduml e772a08ed061126d842f7f5b3627b1d48ab4f90ccf4f1763b61c8368faa9fe642aa5b3225a47c177bc25a63d1992aa5c1b28abcade31c243b6a731a4bc7b1f05","title":"1.2 Diagrama de Componentes"},{"location":"rup/uml/#13-diagrama-de-despliegue-deployment","text":"@startuml node \"Servidor Web\" { [Aplicaci\u00f3n Web] } node \"Servidor DB\" { [Base de Datos] } [Aplicaci\u00f3n Web] --> [Base de Datos] @enduml dc3a0444a916b4fe1482616df3eb598b6c0d675141e595835ab05f12e7eca9d40dc26656849a9b5e7b4832e5b58fe90c3148142966fb626f94cbff8e6be28aa2","title":"1.3 Diagrama de Despliegue (Deployment)"},{"location":"rup/uml/#2-diagramas-de-comportamiento","text":"","title":"2. Diagramas de Comportamiento"},{"location":"rup/uml/#21-diagrama-de-casos-de-uso","text":"@startuml actor Cliente actor Administrador Cliente --> (Comprar Producto) Cliente --> (Consultar Producto) Administrador --> (Agregar Producto) Administrador --> (Eliminar Producto) @enduml 5464e521aacdc82ec714b854af81604e675da48472cf07353c11373952322ac7c51e46ba468567c36723ae75c7925d563cac425f66f4ce53f9ed33ee88bb604b","title":"2.1 Diagrama de Casos de Uso"},{"location":"rup/uml/#22-diagrama-de-secuencia","text":"@startuml actor Cliente participant Sistema participant Inventario Cliente -> Sistema : solicitarCompra() Sistema -> Inventario : verificarStock() Inventario --> Sistema : stockDisponible() Sistema --> Cliente : confirmarCompra() @enduml d8d8aab2d540b3794c6bb063cad67e337ecb0203512163903455c7bc44d38a5b458b6133f7ed850220179b31ca28ed87255b7c6a1c3bd1dbe91ce3578528ab62","title":"2.2 Diagrama de Secuencia"},{"location":"rup/uml/#23-diagrama-de-actividad","text":"@startuml start :Seleccionar producto; :Agregar al carrito; if (Stock disponible?) then (s\u00ed) :Procesar pago; :Generar factura; else (no) :Mostrar mensaje de error; endif stop @enduml fc6b155e1f2bec5c0ce7b4bd1418302e854a734331f5229e725c95adef1a42205e84b15da4ee53e2afa0ae533e1b99052e4456b6e884154c2337ea66e7dc176d","title":"2.3 Diagrama de Actividad"},{"location":"rup/uml/#24-diagrama-de-estados","text":"@startuml [*] --> Pendiente Pendiente --> Pagado : realizarPago Pagado --> Enviado : enviarProducto Enviado --> Entregado : confirmarEntrega @enduml 80d7bfff776ff6904ec182565abb22a47f6d60c1d9c68be4c82277b7971c43e403b449d0d9cf8f36a17d4f7f9ef4b5c107111a7304b1a7667441a7a8b5d8ca48","title":"2.4 Diagrama de Estados"},{"location":"rup/views-4%2B1/","text":"Rational Unified Process (RUP) y el Modelo 4+1 de Vistas Rational Unified Process (RUP) organiza el desarrollo de software en fases iterativas, mientras que el Modelo 4+1 de Vistas ofrece una forma de documentar y visualizar la arquitectura del sistema desde cinco perspectivas: Vista L\u00f3gica (Logical) Vista de Procesos (Process) Vista de Desarrollo (Development) Vista F\u00edsica (Physical) Vista de Casos de Uso (Use Case) A continuaci\u00f3n se muestra c\u00f3mo se relacionan las etapas de RUP con los diagramas t\u00edpicos de cada vista. 1. Inicio (Inception) En esta fase se define el alcance y los requisitos del sistema. Diagramas usados: Vista de Casos de Uso: Diagramas de casos de uso para identificar actores y funcionalidades clave. Vista L\u00f3gica (preliminar): Diagramas de clases de alto nivel para mostrar conceptos principales. Vista de Procesos (opcional): Diagrama de flujo de trabajo de alto nivel para identificar procesos cr\u00edticos. Objetivo: Validar la viabilidad y definir los l\u00edmites del sistema. 2. Elaboraci\u00f3n (Elaboration) Se refinan los requisitos y se establece la arquitectura. Diagramas usados: Vista L\u00f3gica: Diagramas de clases detallados y diagramas de secuencia para modelar interacciones clave. Vista de Procesos: Diagramas de actividad y colaboraci\u00f3n para mostrar concurrencia y sincronizaci\u00f3n. Vista de Desarrollo: Diagramas de componentes para planificar la estructura de m\u00f3dulos. Vista de Casos de Uso: Refinamiento de casos de uso y escenarios principales. Objetivo: Construir una arquitectura s\u00f3lida y minimizar riesgos t\u00e9cnicos. 3. Construcci\u00f3n (Construction) Se implementa y prueba el sistema. Diagramas usados: Vista de Desarrollo: Diagramas de componentes y paquetes para guiar la implementaci\u00f3n. Vista L\u00f3gica: Diagramas de clases y secuencias para validar dise\u00f1o detallado. Vista de Procesos: Diagramas de comunicaci\u00f3n y actividad para controlar ejecuci\u00f3n concurrente. Objetivo: Producir un sistema funcional listo para pruebas de integraci\u00f3n. 4. Pruebas / Transici\u00f3n (Transition) Se valida el sistema antes de su despliegue. Diagramas usados: Vista de Casos de Uso: Diagramas de casos de uso para pruebas de aceptaci\u00f3n y validaci\u00f3n por el usuario. Vista F\u00edsica: Diagramas de despliegue para planificar la infraestructura de producci\u00f3n. Vista de Procesos: Diagramas de actividad para verificar flujos cr\u00edticos durante la operaci\u00f3n. Objetivo: Garantizar calidad, desempe\u00f1o y satisfacci\u00f3n del usuario. 5. Mantenimiento (Maintenance) Proceso continuo posterior al despliegue. Diagramas usados: Vista de Desarrollo: Diagramas de componentes para planificar mejoras o refactorizaciones. Vista de Casos de Uso: Diagramas de casos de uso para nuevas funcionalidades. Vista F\u00edsica: Diagramas de despliegue para cambios en infraestructura. Objetivo: Mantener y evolucionar el sistema de manera controlada. Resumen visual Fase Casos de Uso L\u00f3gica Procesos Desarrollo F\u00edsica Inicio \u2705 \u26aa \u26aa \u26aa \u26aa Elaboraci\u00f3n \u2705 \u2705 \u2705 \u2705 \u26aa Construcci\u00f3n \u26aa \u2705 \u2705 \u2705 \u26aa Pruebas \u2705 \u26aa \u2705 \u26aa \u2705 Mantenimiento \u2705 \u26aa \u26aa \u2705 \u2705 \u2705 = Principalmente utilizado \u26aa = Opcional / menor relevancia","title":"4+1 Vistas"},{"location":"rup/views-4%2B1/#rational-unified-process-rup-y-el-modelo-41-de-vistas","text":"Rational Unified Process (RUP) organiza el desarrollo de software en fases iterativas, mientras que el Modelo 4+1 de Vistas ofrece una forma de documentar y visualizar la arquitectura del sistema desde cinco perspectivas: Vista L\u00f3gica (Logical) Vista de Procesos (Process) Vista de Desarrollo (Development) Vista F\u00edsica (Physical) Vista de Casos de Uso (Use Case) A continuaci\u00f3n se muestra c\u00f3mo se relacionan las etapas de RUP con los diagramas t\u00edpicos de cada vista.","title":"Rational Unified Process (RUP) y el Modelo 4+1 de Vistas"},{"location":"rup/views-4%2B1/#1-inicio-inception","text":"En esta fase se define el alcance y los requisitos del sistema. Diagramas usados: Vista de Casos de Uso: Diagramas de casos de uso para identificar actores y funcionalidades clave. Vista L\u00f3gica (preliminar): Diagramas de clases de alto nivel para mostrar conceptos principales. Vista de Procesos (opcional): Diagrama de flujo de trabajo de alto nivel para identificar procesos cr\u00edticos. Objetivo: Validar la viabilidad y definir los l\u00edmites del sistema.","title":"1. Inicio (Inception)"},{"location":"rup/views-4%2B1/#2-elaboracion-elaboration","text":"Se refinan los requisitos y se establece la arquitectura. Diagramas usados: Vista L\u00f3gica: Diagramas de clases detallados y diagramas de secuencia para modelar interacciones clave. Vista de Procesos: Diagramas de actividad y colaboraci\u00f3n para mostrar concurrencia y sincronizaci\u00f3n. Vista de Desarrollo: Diagramas de componentes para planificar la estructura de m\u00f3dulos. Vista de Casos de Uso: Refinamiento de casos de uso y escenarios principales. Objetivo: Construir una arquitectura s\u00f3lida y minimizar riesgos t\u00e9cnicos.","title":"2. Elaboraci\u00f3n (Elaboration)"},{"location":"rup/views-4%2B1/#3-construccion-construction","text":"Se implementa y prueba el sistema. Diagramas usados: Vista de Desarrollo: Diagramas de componentes y paquetes para guiar la implementaci\u00f3n. Vista L\u00f3gica: Diagramas de clases y secuencias para validar dise\u00f1o detallado. Vista de Procesos: Diagramas de comunicaci\u00f3n y actividad para controlar ejecuci\u00f3n concurrente. Objetivo: Producir un sistema funcional listo para pruebas de integraci\u00f3n.","title":"3. Construcci\u00f3n (Construction)"},{"location":"rup/views-4%2B1/#4-pruebas-transicion-transition","text":"Se valida el sistema antes de su despliegue. Diagramas usados: Vista de Casos de Uso: Diagramas de casos de uso para pruebas de aceptaci\u00f3n y validaci\u00f3n por el usuario. Vista F\u00edsica: Diagramas de despliegue para planificar la infraestructura de producci\u00f3n. Vista de Procesos: Diagramas de actividad para verificar flujos cr\u00edticos durante la operaci\u00f3n. Objetivo: Garantizar calidad, desempe\u00f1o y satisfacci\u00f3n del usuario.","title":"4. Pruebas / Transici\u00f3n (Transition)"},{"location":"rup/views-4%2B1/#5-mantenimiento-maintenance","text":"Proceso continuo posterior al despliegue. Diagramas usados: Vista de Desarrollo: Diagramas de componentes para planificar mejoras o refactorizaciones. Vista de Casos de Uso: Diagramas de casos de uso para nuevas funcionalidades. Vista F\u00edsica: Diagramas de despliegue para cambios en infraestructura. Objetivo: Mantener y evolucionar el sistema de manera controlada.","title":"5. Mantenimiento (Maintenance)"},{"location":"rup/views-4%2B1/#resumen-visual","text":"Fase Casos de Uso L\u00f3gica Procesos Desarrollo F\u00edsica Inicio \u2705 \u26aa \u26aa \u26aa \u26aa Elaboraci\u00f3n \u2705 \u2705 \u2705 \u2705 \u26aa Construcci\u00f3n \u26aa \u2705 \u2705 \u2705 \u26aa Pruebas \u2705 \u26aa \u2705 \u26aa \u2705 Mantenimiento \u2705 \u26aa \u26aa \u2705 \u2705 \u2705 = Principalmente utilizado \u26aa = Opcional / menor relevancia","title":"Resumen visual"},{"location":"software-design/","text":"Dise\u00f1o de software Bienvenido a la gu\u00eda completa de principios de dise\u00f1o en desarrollo de software. Aqu\u00ed encontrar\u00e1s el \u00edndice de los principales principios que te ayudar\u00e1n a escribir c\u00f3digo m\u00e1s limpio, mantenible y eficiente. Principios Fundamentales KISS (Keep It Simple, Stupid) Mantener la simplicidad como objetivo clave en el dise\u00f1o de software. DRY (Don't Repeat Yourself) Evitar la duplicaci\u00f3n de c\u00f3digo y conocimiento en el sistema. YAGNI (You Aren't Gonna Need It) No implementar funcionalidad hasta que sea realmente necesaria. Principios SOLID S - Single Responsibility Principle Una clase debe tener una sola raz\u00f3n para cambiar. O - Open/Closed Principle Las entidades deben estar abiertas para extensi\u00f3n pero cerradas para modificaci\u00f3n. L - Liskov Substitution Principle Los objetos de una superclase deben ser reemplazables por objetos de sus subclases. I - Interface Segregation Principle Los clientes no deben depender de interfaces que no utilizan. D - Dependency Inversion Principle Depender de abstracciones, no de concreciones. Principios GRASP Information Expert Asignar responsabilidad a la clase que tiene la informaci\u00f3n necesaria. Creator Determinar qui\u00e9n debe ser responsable de crear objetos. Controller Manejar eventos del sistema de manera coordinada. Low Coupling Minimizar las dependencias entre clases. High Cohesion Mantener elementos relacionados juntos. Polymorphism Usar polimorfismo para manejar alternativas basadas en tipos. Pure Fabrication Crear clases artificiales para mantener bajo acoplamiento. Indirection Asignar responsabilidad a un objeto intermedio. Protected Variations Proteger elementos de variaciones en otros elementos. Otros Principios Importantes Composition over Inheritance Favorecer la composici\u00f3n sobre la herencia para reutilizar c\u00f3digo. Law of Demeter Un objeto debe conocer solo sus colaboradores inmediatos. Separation of Concerns Separar diferentes aspectos del programa en secciones distintas. Inversion of Control Invertir el control del flujo de ejecuci\u00f3n del programa. Beneficios de Aplicar Principios de Dise\u00f1o Mantenibilidad - C\u00f3digo m\u00e1s f\u00e1cil de modificar y extender Legibilidad - C\u00f3digo m\u00e1s claro y comprensible Reutilizaci\u00f3n - Componentes m\u00e1s reutilizables Testabilidad - C\u00f3digo m\u00e1s f\u00e1cil de probar Escalabilidad - Sistemas que crecen de manera ordenada Flexibilidad - Adaptaci\u00f3n m\u00e1s sencilla a cambios de requisitos Recuerda: Los principios de dise\u00f1o son gu\u00edas fundamentales para crear software de calidad. Apl\u00edcalos de manera consistente para lograr c\u00f3digo m\u00e1s robusto y mantenible.","title":"Introducci\u00f3n al dise\u00f1o de software"},{"location":"software-design/#diseno-de-software","text":"Bienvenido a la gu\u00eda completa de principios de dise\u00f1o en desarrollo de software. Aqu\u00ed encontrar\u00e1s el \u00edndice de los principales principios que te ayudar\u00e1n a escribir c\u00f3digo m\u00e1s limpio, mantenible y eficiente.","title":"Dise\u00f1o de software"},{"location":"software-design/#principios-fundamentales","text":"","title":"Principios Fundamentales"},{"location":"software-design/#kiss-keep-it-simple-stupid","text":"Mantener la simplicidad como objetivo clave en el dise\u00f1o de software.","title":"KISS (Keep It Simple, Stupid)"},{"location":"software-design/#dry-dont-repeat-yourself","text":"Evitar la duplicaci\u00f3n de c\u00f3digo y conocimiento en el sistema.","title":"DRY (Don't Repeat Yourself)"},{"location":"software-design/#yagni-you-arent-gonna-need-it","text":"No implementar funcionalidad hasta que sea realmente necesaria.","title":"YAGNI (You Aren't Gonna Need It)"},{"location":"software-design/#principios-solid","text":"","title":"Principios SOLID"},{"location":"software-design/#s-single-responsibility-principle","text":"Una clase debe tener una sola raz\u00f3n para cambiar.","title":"S - Single Responsibility Principle"},{"location":"software-design/#o-openclosed-principle","text":"Las entidades deben estar abiertas para extensi\u00f3n pero cerradas para modificaci\u00f3n.","title":"O - Open/Closed Principle"},{"location":"software-design/#l-liskov-substitution-principle","text":"Los objetos de una superclase deben ser reemplazables por objetos de sus subclases.","title":"L - Liskov Substitution Principle"},{"location":"software-design/#i-interface-segregation-principle","text":"Los clientes no deben depender de interfaces que no utilizan.","title":"I - Interface Segregation Principle"},{"location":"software-design/#d-dependency-inversion-principle","text":"Depender de abstracciones, no de concreciones.","title":"D - Dependency Inversion Principle"},{"location":"software-design/#principios-grasp","text":"","title":"Principios GRASP"},{"location":"software-design/#information-expert","text":"Asignar responsabilidad a la clase que tiene la informaci\u00f3n necesaria.","title":"Information Expert"},{"location":"software-design/#creator","text":"Determinar qui\u00e9n debe ser responsable de crear objetos.","title":"Creator"},{"location":"software-design/#controller","text":"Manejar eventos del sistema de manera coordinada.","title":"Controller"},{"location":"software-design/#low-coupling","text":"Minimizar las dependencias entre clases.","title":"Low Coupling"},{"location":"software-design/#high-cohesion","text":"Mantener elementos relacionados juntos.","title":"High Cohesion"},{"location":"software-design/#polymorphism","text":"Usar polimorfismo para manejar alternativas basadas en tipos.","title":"Polymorphism"},{"location":"software-design/#pure-fabrication","text":"Crear clases artificiales para mantener bajo acoplamiento.","title":"Pure Fabrication"},{"location":"software-design/#indirection","text":"Asignar responsabilidad a un objeto intermedio.","title":"Indirection"},{"location":"software-design/#protected-variations","text":"Proteger elementos de variaciones en otros elementos.","title":"Protected Variations"},{"location":"software-design/#otros-principios-importantes","text":"","title":"Otros Principios Importantes"},{"location":"software-design/#composition-over-inheritance","text":"Favorecer la composici\u00f3n sobre la herencia para reutilizar c\u00f3digo.","title":"Composition over Inheritance"},{"location":"software-design/#law-of-demeter","text":"Un objeto debe conocer solo sus colaboradores inmediatos.","title":"Law of Demeter"},{"location":"software-design/#separation-of-concerns","text":"Separar diferentes aspectos del programa en secciones distintas.","title":"Separation of Concerns"},{"location":"software-design/#inversion-of-control","text":"Invertir el control del flujo de ejecuci\u00f3n del programa.","title":"Inversion of Control"},{"location":"software-design/#beneficios-de-aplicar-principios-de-diseno","text":"Mantenibilidad - C\u00f3digo m\u00e1s f\u00e1cil de modificar y extender Legibilidad - C\u00f3digo m\u00e1s claro y comprensible Reutilizaci\u00f3n - Componentes m\u00e1s reutilizables Testabilidad - C\u00f3digo m\u00e1s f\u00e1cil de probar Escalabilidad - Sistemas que crecen de manera ordenada Flexibilidad - Adaptaci\u00f3n m\u00e1s sencilla a cambios de requisitos Recuerda: Los principios de dise\u00f1o son gu\u00edas fundamentales para crear software de calidad. Apl\u00edcalos de manera consistente para lograr c\u00f3digo m\u00e1s robusto y mantenible.","title":"Beneficios de Aplicar Principios de Dise\u00f1o"},{"location":"software-design/architecture/","text":"Arquitectura de software La arquitectura de software es una disciplina fundamental en el desarrollo de sistemas inform\u00e1ticos que se enfoca en el dise\u00f1o y organizaci\u00f3n de alto nivel de los componentes de software y sus interacciones. Define la estructura general del sistema, estableciendo c\u00f3mo se organizan, comunican y colaboran los diferentes m\u00f3dulos, servicios y componentes para cumplir con los requisitos funcionales y no funcionales del proyecto. \u00bfQu\u00e9 es la arquitectura de software? La arquitectura de software representa las decisiones de dise\u00f1o m\u00e1s importantes y fundamentales de un sistema, aquellas que son dif\u00edciles de cambiar una vez implementadas. Incluye la definici\u00f3n de componentes, sus responsabilidades, las interfaces entre ellos, y los patrones de interacci\u00f3n que guiar\u00e1n el desarrollo del software. Importancia de la arquitectura de software Escalabilidad : Permite que el sistema pueda crecer y adaptarse a mayores demandas Mantenibilidad : Facilita la modificaci\u00f3n y evoluci\u00f3n del c\u00f3digo a lo largo del tiempo Reutilizaci\u00f3n : Promueve el uso de componentes en diferentes partes del sistema Calidad : Asegura que el software cumpla con est\u00e1ndares de rendimiento, seguridad y confiabilidad Comunicaci\u00f3n : Sirve como lenguaje com\u00fan entre desarrolladores, stakeholders y equipos t\u00e9cnicos Elementos clave Componentes : Unidades modulares de software con responsabilidades espec\u00edficas Conectores : Mecanismos de comunicaci\u00f3n entre componentes Patrones arquitect\u00f3nicos : Soluciones probadas para problemas comunes de dise\u00f1o Vistas arquitect\u00f3nicas : Diferentes perspectivas del sistema (l\u00f3gica, f\u00edsica, de desarrollo, etc.) Restricciones : Limitaciones t\u00e9cnicas, de negocio o de recursos que influyen en el dise\u00f1o La arquitectura de software es esencial para el \u00e9xito de cualquier proyecto de desarrollo, ya que proporciona la base s\u00f3lida sobre la cual se construye todo el sistema.","title":"Arquitectura de software"},{"location":"software-design/architecture/#arquitectura-de-software","text":"La arquitectura de software es una disciplina fundamental en el desarrollo de sistemas inform\u00e1ticos que se enfoca en el dise\u00f1o y organizaci\u00f3n de alto nivel de los componentes de software y sus interacciones. Define la estructura general del sistema, estableciendo c\u00f3mo se organizan, comunican y colaboran los diferentes m\u00f3dulos, servicios y componentes para cumplir con los requisitos funcionales y no funcionales del proyecto.","title":"Arquitectura de software"},{"location":"software-design/architecture/#que-es-la-arquitectura-de-software","text":"La arquitectura de software representa las decisiones de dise\u00f1o m\u00e1s importantes y fundamentales de un sistema, aquellas que son dif\u00edciles de cambiar una vez implementadas. Incluye la definici\u00f3n de componentes, sus responsabilidades, las interfaces entre ellos, y los patrones de interacci\u00f3n que guiar\u00e1n el desarrollo del software.","title":"\u00bfQu\u00e9 es la arquitectura de software?"},{"location":"software-design/architecture/#importancia-de-la-arquitectura-de-software","text":"Escalabilidad : Permite que el sistema pueda crecer y adaptarse a mayores demandas Mantenibilidad : Facilita la modificaci\u00f3n y evoluci\u00f3n del c\u00f3digo a lo largo del tiempo Reutilizaci\u00f3n : Promueve el uso de componentes en diferentes partes del sistema Calidad : Asegura que el software cumpla con est\u00e1ndares de rendimiento, seguridad y confiabilidad Comunicaci\u00f3n : Sirve como lenguaje com\u00fan entre desarrolladores, stakeholders y equipos t\u00e9cnicos","title":"Importancia de la arquitectura de software"},{"location":"software-design/architecture/#elementos-clave","text":"Componentes : Unidades modulares de software con responsabilidades espec\u00edficas Conectores : Mecanismos de comunicaci\u00f3n entre componentes Patrones arquitect\u00f3nicos : Soluciones probadas para problemas comunes de dise\u00f1o Vistas arquitect\u00f3nicas : Diferentes perspectivas del sistema (l\u00f3gica, f\u00edsica, de desarrollo, etc.) Restricciones : Limitaciones t\u00e9cnicas, de negocio o de recursos que influyen en el dise\u00f1o La arquitectura de software es esencial para el \u00e9xito de cualquier proyecto de desarrollo, ya que proporciona la base s\u00f3lida sobre la cual se construye todo el sistema.","title":"Elementos clave"},{"location":"software-design/patterns/","text":"Patrones de dise\u00f1o Los patrones de dise\u00f1o son soluciones reutilizables a problemas comunes que ocurren en el dise\u00f1o de software. Proporcionan un vocabulario compartido entre desarrolladores y representan las mejores pr\u00e1cticas evolucionadas a lo largo del tiempo. Estos patrones se clasifican en tres categor\u00edas principales seg\u00fan su prop\u00f3sito: Creacionales : Se enfocan en la creaci\u00f3n de objetos de manera flexible y reutilizable Estructurales : Tratan sobre la composici\u00f3n de clases y objetos para formar estructuras m\u00e1s grandes Comportamentales : Se centran en la comunicaci\u00f3n entre objetos y la asignaci\u00f3n de responsabilidades Patrones Creacionales Singleton - Garantiza una \u00fanica instancia de una clase Factory Method - Crea objetos sin especificar su clase exacta Abstract Factory - Crea familias de objetos relacionados Builder - Construye objetos complejos paso a paso Prototype - Crea objetos clonando instancias existentes Patrones Estructurales Adapter - Permite que interfaces incompatibles trabajen juntas Bridge - Separa abstracci\u00f3n de implementaci\u00f3n Composite - Compone objetos en estructuras de \u00e1rbol Decorator - A\u00f1ade funcionalidad a objetos din\u00e1micamente Facade - Proporciona una interfaz simplificada Flyweight - Comparte eficientemente objetos similares Proxy - Proporciona un sustituto o placeholder Patrones Comportamentales Chain of Responsibility - Pasa solicitudes a trav\u00e9s de una cadena Command - Encapsula solicitudes como objetos Iterator - Accede secuencialmente a elementos de una colecci\u00f3n Mediator - Define comunicaci\u00f3n entre objetos Memento - Captura y restaura estados de objetos Observer - Notifica cambios a m\u00faltiples objetos State - Altera comportamiento cuando cambia el estado interno Strategy - Encapsula algoritmos y los hace intercambiables Template Method - Define esqueleto de algoritmo en clase base Visitor - Separa algoritmos de la estructura de objetos","title":"Patrones de dise\u00f1o"},{"location":"software-design/patterns/#patrones-de-diseno","text":"Los patrones de dise\u00f1o son soluciones reutilizables a problemas comunes que ocurren en el dise\u00f1o de software. Proporcionan un vocabulario compartido entre desarrolladores y representan las mejores pr\u00e1cticas evolucionadas a lo largo del tiempo. Estos patrones se clasifican en tres categor\u00edas principales seg\u00fan su prop\u00f3sito: Creacionales : Se enfocan en la creaci\u00f3n de objetos de manera flexible y reutilizable Estructurales : Tratan sobre la composici\u00f3n de clases y objetos para formar estructuras m\u00e1s grandes Comportamentales : Se centran en la comunicaci\u00f3n entre objetos y la asignaci\u00f3n de responsabilidades","title":"Patrones de dise\u00f1o"},{"location":"software-design/patterns/#patrones-creacionales","text":"Singleton - Garantiza una \u00fanica instancia de una clase Factory Method - Crea objetos sin especificar su clase exacta Abstract Factory - Crea familias de objetos relacionados Builder - Construye objetos complejos paso a paso Prototype - Crea objetos clonando instancias existentes","title":"Patrones Creacionales"},{"location":"software-design/patterns/#patrones-estructurales","text":"Adapter - Permite que interfaces incompatibles trabajen juntas Bridge - Separa abstracci\u00f3n de implementaci\u00f3n Composite - Compone objetos en estructuras de \u00e1rbol Decorator - A\u00f1ade funcionalidad a objetos din\u00e1micamente Facade - Proporciona una interfaz simplificada Flyweight - Comparte eficientemente objetos similares Proxy - Proporciona un sustituto o placeholder","title":"Patrones Estructurales"},{"location":"software-design/patterns/#patrones-comportamentales","text":"Chain of Responsibility - Pasa solicitudes a trav\u00e9s de una cadena Command - Encapsula solicitudes como objetos Iterator - Accede secuencialmente a elementos de una colecci\u00f3n Mediator - Define comunicaci\u00f3n entre objetos Memento - Captura y restaura estados de objetos Observer - Notifica cambios a m\u00faltiples objetos State - Altera comportamiento cuando cambia el estado interno Strategy - Encapsula algoritmos y los hace intercambiables Template Method - Define esqueleto de algoritmo en clase base Visitor - Separa algoritmos de la estructura de objetos","title":"Patrones Comportamentales"}]}